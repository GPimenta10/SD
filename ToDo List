2. Lista de Eventos Discretos AUSENTE üî¥
    Requisito do enunciado (Se√ß√£o 7): "A simula√ß√£o deve ser baseada no paradigma de eventos discretos. Cada evento representa uma altera√ß√£o de estado no sistema..."

    Lista de Eventos: estrutura de dados ordenada por tempo 
    Rel√≥gio da Simula√ß√£o: avan√ßa para o pr√≥ximo evento
    Estados do Sistema: n√∫mero de ve√≠culos, sem√°foros, tempos

    // Classe sugerida: GestorEventos.java
    public class GestorEventos {
        private final PriorityQueue<Evento> eventos; // ordenados por tempo
        private long relogioSimulacao = 0;
        
        public void agendarEvento(TipoEvento tipo, long tempo, Object dados) {
            eventos.add(new Evento(tipo, tempo, dados));
        }
        
        public void executarProximoEvento() {
            Evento e = eventos.poll();
            relogioSimulacao = e.getTempo();
            // processar evento...
        }
    }
    
    enum TipoEvento {
        CHEGADA_VEICULO,
        MUDANCA_SEMAFORO,
        SAIDA_VEICULO,
        FIM_TRAVESSIA_RUA
    }
    
    Impacto:
    
    	Simula√ß√£o √© baseada em tempo real (Thread.sleep) em vez de eventos discretos
    	Dificulta an√°lise determin√≠stica
    	Imposs√≠vel "avan√ßar r√°pido" na simula√ß√£o

3. Estat√≠sticas dos Cruzamentos n√£o v√£o para o Dashboard ‚ö†Ô∏è
    O que o enunciado pede (Se√ß√£o 8):
    
    "Cada processo deve enviar periodicamente os dados para um servidor central"
    
    Tamanho atual das filas
    Tamanho m√°ximo e m√©dio
    Quantos ve√≠culos de cada tipo passaram
    
    // Adicionar em Cruzamento.java
    private void enviarEstatisticasPeriodicas() {
        ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
        scheduler.scheduleAtFixedRate(() -> {
            filasPorDirecao.forEach((dir, fila) -> {
                String stats = String.format("[Fila] %s atual=%d max=%d processados=%d",
                    identificador, fila.getTamanhoAtual(), 
                    fila.getTamanhoMaximo(), fila.getTotalProcessados());
                dashboard.enviar(stats);
            });
        }, 1, 2, TimeUnit.SECONDS); // a cada 2 segundos
    }


4. Crit√©rio de Paragem n√£o Implementado ‚ö†Ô∏è

    Enunciado (Se√ß√£o 7): "A simula√ß√£o termina quando o tempo total atinge um valor m√°ximo predefinido ou quando todos os ve√≠culos saem do sistema"
    
    C√≥digo atual:
    
        // Main.java
        Thread.sleep(15000); // ‚ùå Tempo fixo arbitr√°rio
        finalizarProcessos();
    
    Solu√ß√£o:
    
        // Op√ß√£o 1: Por tempo de simula√ß√£o
        if (relogioSimulacao >= TEMPO_MAXIMO_SIMULACAO) {
            finalizarSimulacao();
        }
        
        // Op√ß√£o 2: Quando todos sa√≠rem
        if (totalVeiculosGerados == totalVeiculosSaida && todasFilasVazias()) {
            finalizarSimulacao();
        }


PRIORIDADES DE CORRE√á√ÉO
      Alta Prioridade (Afetam nota final):

      ‚úÖImplementar serializa√ß√£o de ve√≠culos (perdem-se dados cr√≠ticos) - J√° Feito
        Adicionar lista de eventos discretos (requisito expl√≠cito)
        Enviar estat√≠sticas de filas ao Dashboard (se√ß√£o 8)
      
      M√©dia Prioridade:
      
        Implementar crit√©rio de paragem inteligente
        Adicionar pol√≠ticas adaptativas de sem√°foros
        Testar cen√°rios de baixa/m√©dia/alta carga
      
      Baixa Prioridade (melhorias):
      
        Expandir para malha 3x3 completa
        Algoritmos alternativos de sele√ß√£o de caminhos
      
      O que PRECISA de aten√ß√£o:
      
        Eventos discretos - requisito expl√≠cito do enunciado
        Dashboard completo - falta receber estat√≠sticas das filas
